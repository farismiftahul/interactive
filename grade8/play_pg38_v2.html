<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Group Game — Request/Permission (robust placement)</title>
<style>
  body{font-family:Arial;margin:18px;color:#111}
  h1{font-size:18px;margin-bottom:8px}
  .layout{display:flex;gap:14px}
  .left{width:300px}
  .controls{background:#f7f7f7;padding:10px;border-radius:8px;border:1px solid #e6e6e6}
  .groups{display:flex;flex-direction:column;gap:6px;margin:8px 0}
  .group{padding:8px;border-radius:6px;border:1px solid #ddd;background:#fff;display:flex;align-items:center;gap:8px}
  .group.active{outline:3px solid rgba(41,121,255,0.12)}
  .board{flex:1;display:flex;flex-direction:column;gap:12px}
  .zones{display:flex;gap:10px}
  .zone{flex:1;border:2px dashed #bbb;border-radius:8px;min-height:180px;padding:10px;background:#fafafa}
  .zone h3{text-align:center;margin:2px 0 8px}
  .card{background:#fff;padding:8px;border:1px solid #ccc;border-radius:6px;margin-bottom:8px;cursor:grab}
  .card.selected{box-shadow:0 0 0 3px rgba(41,121,255,0.10)}
  .card.assigned{opacity:0.6;cursor:default}
  .pool{border:1px solid #eee;padding:8px;border-radius:6px;background:#fff;min-height:80px}
  .actions{margin-top:8px;display:flex;gap:6px}
  button{padding:8px 10px;border-radius:6px;border:0;background:#2979ff;color:#fff;cursor:pointer}
  button.ghost{background:#eee;color:#222}
  .meta{font-size:12px;color:#666;margin-top:6px}
  .status{font-size:13px;margin-top:8px}
</style>
</head>
<body>
<h1>Group Game — Request or Permission (placement fallback included)</h1>

<div class="layout">
  <div class="left">
    <div class="controls">
      <div><strong>Teams</strong></div>
      <div style="margin-top:8px">
        <label>Groups: <input id="groupCount" type="number" min="2" max="10" value="5" style="width:60px;padding:4px"/></label>
        <button id="apply" style="margin-left:6px">Apply</button>
      </div>
      <div class="groups" id="groupsList"></div>

      <div style="margin-top:8px">
        <button id="startRound">Start Round</button>
        <button id="endTurn" class="ghost">End Turn</button>
        <div class="status" id="status">Round not started.</div>
      </div>

      <div style="margin-top:10px">
        <div><strong>Placement helper (works on mobile)</strong></div>
        <div class="actions" style="margin-top:6px">
          <button id="placeRequest" class="ghost">Place → REQUEST</button>
          <button id="placePermission" class="ghost">Place → PERMISSION</button>
        </div>
        <div style="margin-top:8px"><button id="resetBtn" class="ghost">Reset game</button></div>
      </div>
    </div>
  </div>

  <div class="board">
    <div class="zones">
      <div class="zone" id="requestsZone"><h3>REQUEST</h3><div id="requestsColumn"></div></div>
      <div class="zone" id="permissionsZone"><h3>PERMISSION</h3><div id="permissionsColumn"></div></div>
    </div>

    <div>
      <h3>Available sentences</h3>
      <div class="pool" id="cardPool"></div>
      <div class="meta" id="selectedMeta">No sentence selected.</div>
    </div>
  </div>
</div>

<script>
/* ----- dialogues (editable) ----- */
const dialogues = [
  {id:1, text:"Excuse me, could I borrow your pen?", type:"request"},
  {id:2, text:"May I leave early today?", type:"permission"},
  {id:3, text:"Could you help me with my homework?", type:"request"},
  {id:4, text:"Can I join your study group?", type:"permission"},
  {id:5, text:"Would you mind opening the window?", type:"request"},
  {id:6, text:"May I use your phone for a moment?", type:"permission"},
  {id:7, text:"Could we schedule the meeting for Monday?", type:"request"},
  {id:8, text:"Can I have a glass of water?", type:"request"},
  {id:9, text:"Would you mind if I sat here?", type:"permission"},
  {id:10, text:"You may choose any seat you like.", type:"permission"},
  {id:11, text:"Could you pass the salt, please?", type:"request"},
  {id:12, text:"May I see the menu, please?", type:"request"}
];

/* ----- state and UI refs ----- */
let cards = []; // {id,text,type,assigned,placedIn,placedBy}
let groups = []; // {name,score}
let currentGroup = null; // index
let roundActive = false;
let selectedCardId = null;

const cardPool = document.getElementById('cardPool');
const requestsColumn = document.getElementById('requestsColumn');
const permissionsColumn = document.getElementById('permissionsColumn');
const groupsList = document.getElementById('groupsList');
const groupCountEl = document.getElementById('groupCount');
const applyBtn = document.getElementById('apply');
const startBtn = document.getElementById('startRound');
const endBtn = document.getElementById('endTurn');
const statusEl = document.getElementById('status');
const placeRequestBtn = document.getElementById('placeRequest');
const placePermissionBtn = document.getElementById('placePermission');
const resetBtn = document.getElementById('resetBtn');
const selectedMeta = document.getElementById('selectedMeta');

/* ----- functions ----- */
function init(){
  cards = dialogues.map(d=>({ ...d, assigned:false, placedIn:null, placedBy:null }));
  buildGroups(Number(groupCountEl.value || 5));
  renderAll();
}

function buildGroups(n){
  groups = [];
  for(let i=0;i<n;i++) groups.push({ name:`Group ${i+1}`, score:0 });
  renderGroups();
}

function renderGroups(){
  groupsList.innerHTML = '';
  groups.forEach((g,i)=>{
    const el = document.createElement('div');
    el.className = 'group' + (currentGroup===i ? ' active':'');
    el.textContent = `${g.name} — ${g.score}`;
    groupsList.appendChild(el);
  });
}

function renderAll(){
  renderPool();
  renderColumns();
  renderGroups();
  updateSelectedMeta();
}

function renderPool(){
  cardPool.innerHTML = '';
  cards.forEach(c=>{
    // pool shows unassigned + unplaced, and also placed-but-not-assigned (so teacher/students can move)
    // we will show everything that is not assigned in the pool for selection.
    if(c.assigned) return;
    const el = document.createElement('div');
    el.className = 'card' + (selectedCardId===c.id ? ' selected':'');
    el.draggable = true;
    el.dataset.id = c.id;
    el.textContent = `(${c.id}) ${c.text}`;
    // dragstart: set id as string
    el.addEventListener('dragstart', e=> {
      e.dataTransfer.setData('text/plain', String(c.id));
    });
    // click selects
    el.addEventListener('click', ()=> {
      selectedCardId = (selectedCardId===c.id) ? null : c.id;
      renderAll();
    });
    // if the card is placed, show small meta
    if(c.placedIn){
      const m = document.createElement('div'); m.className='meta';
      m.textContent = `Placed: ${c.placedIn} by ${groups[c.placedBy].name}`;
      el.appendChild(m);
    }
    cardPool.appendChild(el);
  });
}

function renderColumns(){
  requestsColumn.innerHTML=''; permissionsColumn.innerHTML='';
  cards.forEach(c=>{
    if(!c.placedIn) return;
    const el = document.createElement('div');
    el.className = 'card' + (c.assigned ? ' assigned':'');
    el.textContent = `(${c.id}) ${c.text}`;
    if(c.assigned){
      const m = document.createElement('div'); m.className='meta';
      m.textContent = `Assigned to ${groups[c.placedBy].name}`;
      el.appendChild(m);
    } else {
      const m = document.createElement('div'); m.className='meta';
      m.textContent = `Placed by ${groups[c.placedBy].name}`;
      el.appendChild(m);
    }
    if(c.placedIn === 'request') requestsColumn.appendChild(el);
    else permissionsColumn.appendChild(el);
  });
}

function updateSelectedMeta(){
  if(!selectedCardId){ selectedMeta.textContent = 'No sentence selected.'; return; }
  const c = cards.find(x=>x.id===selectedCardId);
  if(!c) { selectedMeta.textContent = 'Selected sentence not found.'; return; }
  selectedMeta.textContent = `Selected (${c.id}): "${c.text}" — correct = ${c.type.toUpperCase()}`;
}

/* ----- placement helpers (robust) ----- */
function placeSelectedInto(target){ // target: 'request' or 'permission'
  if(!roundActive || currentGroup===null){ alert('Start the round first.'); return; }
  if(!selectedCardId){ alert('Select a sentence first (tap it).'); return; }
  const c = cards.find(x=>x.id===selectedCardId);
  if(!c) return;
  if(c.assigned){ alert('This sentence is locked (assigned).'); return; }
  c.placedIn = target;
  c.placedBy = currentGroup;
  // deselect after placing
  selectedCardId = null;
  renderAll();
}

/* drop handling (desktop) */
[requestsColumn, permissionsColumn].forEach(zone=>{
  zone.addEventListener('dragover', e=> e.preventDefault());
  zone.addEventListener('drop', e=>{
    e.preventDefault();
    if(!roundActive || currentGroup===null){ alert('Start the round first.'); return; }
    const id = e.dataTransfer.getData('text/plain');
    const c = cards.find(x=>String(x.id)===String(id));
    if(!c) return;
    if(c.assigned){ alert('This sentence is locked.'); return; }
    c.placedIn = (zone===requestsColumn) ? 'request' : 'permission';
    c.placedBy = currentGroup;
    selectedCardId = null;
    renderAll();
  });
});

/* ----- game flow ----- */
applyBtn.addEventListener('click', ()=> {
  const n = Math.max(2, Math.min(10, Number(groupCountEl.value) || 5));
  buildGroups(n);
  // reset scores and state
  groups.forEach(g=>g.score=0);
  currentGroup = null; roundActive = false; statusEl.textContent = 'Round not started.';
  cards = dialogues.map(d=>({ ...d, assigned:false, placedIn:null, placedBy:null }));
  renderAll();
});

startBtn.addEventListener('click', ()=>{
  if(groups.length===0) { alert('Apply groups first.'); return; }
  if(roundActive) { alert('Round already active.'); return; }
  roundActive = true; currentGroup = 0;
  statusEl.textContent = 'Current: ' + groups[currentGroup].name;
  renderGroups();
});

endBtn.addEventListener('click', ()=>{
  if(!roundActive || currentGroup===null) return;
  // score placed by current group
  let pts = 0;
  cards.forEach(c=>{
    if(!c.assigned && c.placedBy===currentGroup){
      const correct = (c.type==='request' && c.placedIn==='request') || (c.type==='permission' && c.placedIn==='permission');
      if(correct) pts++;
      // lock them on score by default? We'll keep unlocked — teacher can lock using Reset/Assign if wanted.
      c.assigned = c.assigned || false;
    }
  });
  groups[currentGroup].score += pts;
  // rotate
  currentGroup = (currentGroup + 1) % groups.length;
  statusEl.textContent = `Last scored ${pts}. Next: ${groups[currentGroup].name}`;
  renderAll();
});

placeRequestBtn.addEventListener('click', ()=> placeSelectedInto('request'));
placePermissionBtn.addEventListener('click', ()=> placeSelectedInto('permission'));

resetBtn.addEventListener('click', ()=> {
  if(!confirm('Reset whole game?')) return;
  init();
});

/* initialize */
init();
</script>
</body>
</html>
